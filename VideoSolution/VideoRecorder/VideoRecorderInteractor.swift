//
//  VideoRecorderInteractor.swift
//  VideoSolution
//
//  Created Galean Pallerman on 26.07.2019.
//  Copyright Â© 2019 GPco. All rights reserved.
//
//  Template generated by Galean Pallerman
//

import UIKit
import AVFoundation

fileprivate func tempURL() -> URL {
    let directory = NSTemporaryDirectory() as NSString
    
    let path = directory.appendingPathComponent(NSUUID().uuidString + ".mov")
    return URL(fileURLWithPath: path)
}

//MARK:-
class VideoRecorderInteractor: NSObject {
    private var videoRecorderModel: VideoRecorderModelProtocol = VideoRecorderModel()
    private var videoOutputModel: VideoOutputModelProtocol = VideoOutputModel()
    private var cameraRollModel: CameraRollModelProtocol = CameraRollModel()
    
    weak var presenter: VideoRecorderInteractorToPresenterProtocol!
    
    //MARK: Initialization
    func configure(presenter: VideoRecorderInteractorToPresenterProtocol) {
        self.presenter = presenter
    }
    
    fileprivate func internalValidateTorch() {
        let isTorchSupported = videoOutputModel.isTorchSupported
        let mode = isTorchSupported ? videoOutputModel.currentTorchMode: nil
        presenter.handleTorch(isSupported: videoOutputModel.isTorchSupported,
                              mode: mode)
    }
}

//MARK:- VideoRecorderPresenterToInteractorProtocol
extension VideoRecorderInteractor: VideoRecorderPresenterToInteractorProtocol {
    func requestedSwitchCamera() {
        videoOutputModel.switchCamera()
    }
    
    func requestedHandleViewDidLoad() {
        videoOutputModel.delegate = self
        videoOutputModel.setup()
        
        videoRecorderModel.delegate = self
        
        cameraRollModel.delegate = self
        cameraRollModel.fetchCameraRoll()
        
        internalValidateTorch()
        presenter.handleAudio(muted: videoRecorderModel.audioMuted)
    }
    
    func requestedGallery() {
        
    }
    
    func requestedStartRecording() {
        videoRecorderModel.startRecording()
    }
    
    func requestedStopRecording() {
        videoRecorderModel.stopRecording()
    }
    
    func requestedMute() {
        videoRecorderModel.audioMuted = !videoRecorderModel.audioMuted
        presenter.handleAudio(muted: videoRecorderModel.audioMuted)
    }
    
    func requestedTorch() {
        let torchAvailable = videoOutputModel.isTorchSupported
        
        guard torchAvailable == true else {
            presenter.handleTorch(isSupported: false,
                                  mode: nil)
            return
        }
        
        let torchMode = videoOutputModel.currentTorchMode
        var newTorchMode = AVCaptureDevice.TorchMode.auto
        switch torchMode {
        case .auto:
            newTorchMode = .on
        case .on:
            newTorchMode = .off
        default:
            newTorchMode = .auto
        }
        
        videoOutputModel.currentTorchMode = newTorchMode
        presenter.handleTorch(isSupported: true,
                              mode: videoOutputModel.currentTorchMode)
    }
}

//MARK:- CameraRollModelDelegate
extension VideoRecorderInteractor: CameraRollModelDelegate {
    func fetchedCameraRoll(galleryLastImage imageData: GalleryPreviewData) {
        presenter.updateCameraRollPreview(with: imageData)
    }
}

//MARK:- VideoOutputModelDelegate
extension VideoRecorderInteractor: VideoOutputModelDelegate {
    func capturedMovieOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
        let image = CIImage.create(from: sampleBuffer)
        
        let samplePixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer)!
        image.convert(into: samplePixelBuffer)
        
        presenter.display(videoPreview: image)
        videoRecorderModel.videoOutputToRecord(output, didOutput: sampleBuffer,
                                               assosiatedPixelBuffer: samplePixelBuffer,
                                               from: connection)
    }
    
    func capturedAudioOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
        videoRecorderModel.audioOutputToRecord(output, didOutput: sampleBuffer, from: connection)
    }
    
    func switchedCamera(to position: AVCaptureDevice.Position) {
        presenter.displayVideoInputChange()
        
        internalValidateTorch()
    }
}

//MARK:- VideoRecorderInteractor
extension VideoRecorderInteractor: VideoRecorderModelDelegate {
    func videoSavedToTheCameraRoll() {
        cameraRollModel.fetchCameraRoll()
    }
}
